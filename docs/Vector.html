<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Sha256.html">Sha256</a></li></li><li><li><a href="Sha512.html">Sha512</a></li></li><li><li><a href="Vector.html">Vector</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Vector">Vector</a></li></li><li><li><a href="#new">new</a></li></li><li><li><a href="#clear">clear</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#removeLast">removeLast</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#getOpt">getOpt</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#vals">vals</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#toArray">toArray</a></li></li><li><li><a href="#fromArray">fromArray</a></li></li><li><li><a href="#toVarArray">toVarArray</a></li></li><li><li><a href="#fromVarArray">fromVarArray</a></li></li></ul></nav><div class="documentation"><h1>Vector</h1><p>Resizable one-dimensional array with <code>O(sqrt(n))</code> memory waste.</p>
<div class="declaration"><h4 class="type-declaration" id="type.Vector"><span class="keyword">type </span><span class="type">Vector</span>&lt;<span class="type">X</span>&gt; = { <span class="keyword">var </span>data_blocks : [<span class="keyword">var </span>[<span class="keyword">var </span>?<span class="type">X</span>]]; <span class="keyword">var </span>i_block : <span class="type">Nat</span>; <span class="keyword">var </span>i_element : <span class="type">Nat</span> }</h4><p><p>Class <code>Vector&lt;X&gt;</code> provides a mutable list of elements of type <code>X</code>.
It is a substitution for <code>Buffer&lt;X&gt;</code> with <code>O(sqrt(n))</code> memory waste instead of <code>O(n)</code> where
n is the size of the data strucuture.
Based on the paper &quot;Resizable Arrays in Optimal Time and Space&quot; by Brodnik, Carlsson, Demaine, Munro and Sedgewick (1999). 
Since this is internally a two-dimensional array the access times for put and get operations
will naturally be 2x slower than Buffer and Array. However, Array is not resizable and Buffer
has O(n) memory waste.</p>
</p></div><div class="declaration"><h4 class="function" id="new"><code><span class="keyword">public func </span><span class="fnname">new</span>&lt;<span class="type">X</span>&gt;() : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a new empty Vector for elements of type X.</p>
<p>Example:</p>
<pre><code>motoko name=initialize
let vec = Vector.new&lt;Nat&gt;(); // Creates a new Vector</code></pre></p></div><div class="declaration"><h4 class="function" id="clear"><code><span class="keyword">public func </span><span class="fnname">clear</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Resets the vector to size 0, de-referencing all elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.add(vec, 11);
Vector.add(vec, 12);
Vector.clear(vec); // vector is now empty
Vector.toArray(vec) // =&gt; []</code></pre>

<p>Runtime: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns a copy of a Vector, with the same size.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

vec.add(1);

let clone = Vector.clone(vec);
Vector.toArray(clone); // =&gt; [1]</code></pre>

<p>Runtime: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Returns the current number of elements in the vector.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
Vector.size(vec) // =&gt; 0</code></pre>

<p>Runtime: O(1) (with some internal calculations)</p>
</p></div><div class="declaration"><h4 class="function" id="add"><code><span class="keyword">public func </span><span class="fnname">add</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">element</span> : <span class="type">X</span>)</code></h4><p><p>Adds a single element to the end of a Vector, 
allocating a new internal data block if needed, 
and resizing the internal index block if needed.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 0); // add 0 to vector
Vector.add(vec, 1);
Vector.add(vec, 2);
Vector.add(vec, 3);
Vector.toArray(vec) // =&gt; [0, 1, 2, 3]</code></pre>

<p>Amortized Runtime: O(1), Worst Case Runtime: O(sqrt(n))</p>
</p></div><div class="declaration"><h4 class="function" id="removeLast"><code><span class="keyword">public func </span><span class="fnname">removeLast</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : ?<span class="type">X</span></code></h4><p><p>Removes and returns the last item in the vector or <code>null</code> if
the vector is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.add(vec, 11);
Vector.removeLast(vec); // =&gt; ?11</code></pre>

<p>Amortized Runtime: O(1), Worst Case Runtime: O(sqrt(n))</p>
<p>Amortized Space: O(1), Worst Case Space: O(sqrt(n))</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : <span class="type">X</span></code></h4><p><p>Returns the element at index <code>index</code>. Indexing is zero-based.
Traps if <code>index &gt;= size</code>, error message may not be descriptive.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.add(vec, 11);
Vector.get(vec, 0); // =&gt; 10</code></pre>

<p>Runtime: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="getOpt"><code><span class="keyword">public func </span><span class="fnname">getOpt</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : ?<span class="type">X</span></code></h4><p><p>Returns the element at index <code>index</code> as an option.
Returns <code>null</code> when <code>index &gt;= size</code>. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.add(vec, 11);
let x = Vector.getOpt(vec, 0); // =&gt; ?10
let y = Vector.getOpt(vec, 2); // =&gt; null</code></pre>

<p>Runtime: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">index</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">value</span> : <span class="type">X</span><br/>)</code></h4><p><p>Overwrites the current element at <code>index</code> with <code>element</code>. Traps if
<code>index</code> &gt;= size. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.put(vec, 0, 20); // overwrites 10 at index 0 with 20
Vector.toArray(vec) // =&gt; [20]</code></pre>

<p>Runtime: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="vals"><code><span class="keyword">public func </span><span class="fnname">vals</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">Iter.Iter</span>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the elements of a Vector.
Iterator provides a single method <code>next()</code>, which returns
elements in order, or <code>null</code> when out of elements to iterate over.</p>
<pre><code>motoko include=initialize

Vector.add(vec, 10);
Vector.add(vec, 11);
Vector.add(vec, 12);

var sum = 0;
for (element in Vector.vals(vec)) {
  sum += element;
};
sum // =&gt; 33</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the 
Vector, then this may lead to unexpected results.</p>
<p>Runtime: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">iter</span> : <span class="type">Iter.Iter</span>&lt;<span class="type">X</span>&gt;) : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a Vector containing elements from <code>iter</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [1, 1, 1];
let iter = array.vals();

let vec = Vector.fromIter&lt;Nat&gt;(iter); // =&gt; [1, 1, 1]</code></pre>

<p>Runtime: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : [<span class="type">X</span>]</code></h4><p><p>Creates an immutable array containing elements from a Vector.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 1);
Vector.add(vec, 2);
Vector.add(vec, 3);

Vector.toArray&lt;Nat&gt;(vec); // =&gt; [1, 2, 3]

</code></pre>

<p>Runtime: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="fromArray"><code><span class="keyword">public func </span><span class="fnname">fromArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">array</span> : [<span class="type">X</span>]) : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a Vector containing elements from an Array.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [2, 3];

let vec = Vector.fromArray&lt;Nat&gt;(array); // =&gt; [2, 3]</code></pre>

<p>Runtime: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="toVarArray"><code><span class="keyword">public func </span><span class="fnname">toVarArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">vec</span> : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;) : [<span class="keyword">var </span><span class="type">X</span>]</code></h4><p><p>Creates a mutable Array containing elements from a Vector.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

Vector.add(vec, 1);
Vector.add(vec, 2);
Vector.add(vec, 3);

Vector.toVarArray&lt;Nat&gt;(vec); // =&gt; [1, 2, 3]

</code></pre>

<p>Runtime: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="fromVarArray"><code><span class="keyword">public func </span><span class="fnname">fromVarArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">array</span> : [<span class="keyword">var </span><span class="type">X</span>]) : <a href="#type.Vector"><span class="type">Vector</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a Vector containing elements from a mutable Array.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [var 2, 3];

let vec = Vector.fromVarArray&lt;Nat&gt;(array); // =&gt; [2, 3]</code></pre>

<p>Runtime: O(n)</p>
</p></div></div></body></html>